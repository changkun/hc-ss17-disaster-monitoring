\section{Design}

In this chapter, we describe the overall design of our disaster monitoring backend system in details.
Firstly, we propose our system architecture of this disaster monitoring;
Then we specify and justify our most critical system components such as databases design, 
\textbf{Player Task Generator (PTG)\label{idx:ptg}}, \textbf{Player Rating Model (PRM)\label{idx:prm}} 
as well as \textbf{Disaster Evaluation Model (DEM)\label{idx:dem}}.

With these components, model and databases, the disaster monitoring system can handle
common problems in HC system, such as cold start, malicious player detection, etc. 
It is also expandable, portable and can be easily applied to any other same image selection 
and tagging based HC system in different areas.

\subsection{System Architectures}

Figure \ref{fig:arch} illustrate the overall disaster system design.
The system databases are composed of two different type of databases. 
The first database \textbf{PlayerDB} combines \textbf{TrustedDB} and \textbf{UntrustedDB} 
where persistent the player property and raw tagging inputs whether the overall result is reliable or not.
The second database is called \textbf{ResultDB} where persistent the reliable player inputs.

\begin{figure}[htp]
\centering
\includegraphics[width=0.9\textwidth]{figures/system2}
\caption{System Design Overview}
\label{fig:arch}
\end{figure}

For this architecture design, one can simplify the overall data flow into tree main steps 
that describes as follows:

\begin{itemize}

\item [Step 1.]  Player task generating: 
We propose the \textbf{\hyperref[idx:ptg]{PTG}}
that combines trusted results from \textbf{TrustedDB}, 
and separate new images from satellite, then assign this binding to the future players.

\item [Step 2.] Malicious player detection: 
A reliable player shall pass the malicious detection algorithm (describe in algorithm \ref{algo:malicious})
inside the \textbf{\hyperref[idx:prm]{PRM}}. 
Once the player is not a malicious player, then system will mark all the results from this player
as a reliable result and then send it into next step.

\item [Step 3.] Evaluating disaster level:  the system reuse the reliable player inputs 
into \textbf{\hyperref[idx:dem]{DEM}} and calculate the disaster level of the monitoring region
 as well as persistent it in the second database \textbf{ResultDB}.

\end{itemize}

After these three main steps, stakeholders are able to retrieve monitoring results from
the database \textbf{ResultDB}. 

\subsection{System Components}

\subsubsection{Database Fields}

We describe the system database PlayerDB 
fields as well as the fields of database ResultDB first in listing \ref{lst:playerdb}
and \ref{lst:resultdb}.

In this disaster monitoring system, our participants \textbf{do not need to register accounts},
and the system backend shall \textbf{generate and assign an} \emph{player\_id} \textbf{to each player} according to 
the user scenario (such as IP address, network status, system information et cetera).
This function significantly accelerate player to participate in this game. 
Thus, the \textbf{PlayerDB} stores the \emph{player\_id} to detect the same players if they participate next time. 
The player will accomplish different game tasks; each task result shall store in the tasks filed.

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[
    caption={Example of Player Database Data},
    label={lst:playerdb}
]
[
 {
  "player_id": "E3A6F124-4A6C-4C6E-B7F1-F8BC9A7381CC",
  "tasks": [
   {
    "image_id": "3A21E99E-F074-454B-A590-8D8C5ABD8E77",
    "image_at": "2017-07-31 11:28:40",
    "reliable": true,
    "ROIs": [
     {
      "x": 103, "y": 121,
      "height": 56,
      "width": 78,
      "tags": ["burning building", "explosion"]
     }
    ]
   }
  ]
 }
]
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[
  caption={Example of Results Database Data},
  label={lst:resultdb}
]
[
 {
  "region_id": "FBEB6204-0B94-4811-94F0-9DDC5FBBE6D8",
  "history": [
   {
    "image_id": "3A21E99E-F074-454B-A590-8D8C5ABD8E77",
    "image_at": "2017-07-31 11:28:40",
    "ROIs": [
     {
      "x": 103, "y": 121,
      "height": 56,
      "width": 78,
      "tags": ["burning building", "explosion"]
     }
    ]
   }
  ]
 }
]
\end{lstlisting}
\end{minipage}

In the \textbf{ResultDB}, a \emph{region\_id} is unique and assigned by our system. A region has its
monitoring history and composed by its separate images, the only difference between PlayerDB and ResultDB is
ResultDB only stores reliable data (no \emph{reliable} field) and images organized by its related region.

To explain other fields and establish our models, we describe few basic definitions for the system models first.

\begin{definition}
\label{def:roi}
\emph{The \textbf{Region of Interests (ROI)} is an indicator that represents the one of the selected two dimensional regions from player. 
The $i$-th ROI from player $p$ in image $k$ at image creation time $t$ is denoted by $ROI_{p,i,k,t}$.}
\end{definition}

Considering image $k$ \textbf{implies} its creation time $t$ (an image alwasy has its creation time), for convenience, 
we usually \textbf{simplify $ROI_{p,i,k,t}$ to $ROI_{p,i,k}$}.
For instance, figure \ref{fig:roi} shows few examples of ROI on different images.

\begin{figure}[htp]
\centering
\includegraphics[width=0.9\textwidth]{figures/roi}
\caption{Examples of Region of Interests (ROI)}
\label{fig:roi}
\end{figure}

With this definition, our system players are able to select ROIs for each image as well as capable of select tags for each ROI.
Thus, the \emph{tasks} field in PlayerDB is an array object, stores each player image result with an assigned \emph{image\_id}.
Each object in the \emph{tasks} array has a field \emph{reliable}, which indicates the reliability for this object task;
Each object also contains a \emph{ROIs} field, which is an array object that contains the player inputs for this object image;
Each ROI object in the ROIs field has four properties that describes the ROI geometric location: \emph{x, y, height, width}, and 
also a \emph{tags} array field that describes the input tags for this image from this player.

For \emph{tags} field,
game players select the related tags for each ROI, and stores in this array. \textbf{Each tag can only selects once, 
and players allow to input their own new tags for this ROI.} Then, We define the ROI tag vector for the model design:

\begin{definition}
\label{def:tagv}
\emph{Assuming the database stores $n$ different tags $\text{tag}_1, \text{tag}_2, ..., \text{tag}_n$ for a certain image $k$,
the \textbf{Tag Vector} $T_{p, i, k}$ of $ROI_{p, i, k}$ (the $i$-th ROI in image $k$ of player $p$) is a vector that 
is donated by the following formula:}

\[
  T_{p, i, k} = (|\text{tag}_1|, |\text{tag}_2|, ..., |\text{tag}_n|)
\]
\emph{where
\begin{itemize}
\item $tag_i$ is the $i$-th tag;
\item $n$ is the number of tags;
\item $|\text{tag}_i|$ is the count of $\text{tag}_i$ in a task object.
\end{itemize}}
\end{definition}

Note that due to each tag can only selects once, the components of tag vector is either 1 or 0 in reality.
For instance, for a certain image $k$,
there are 5 different tags $\text{tag}_1, \text{tag}_2, \text{tag}_3, \text{tag}_4, \text{tag}_5$ were inputed
by our game player.
Assuming player $p$ selects the first ROI and inputs tags for $ROI_{p, 1, k}$: 
$\{\text{tag}_1, \text{tag}_2, \text{tag}_3, \text{tag}_4\}$, 
player $q$ selects the first ROI and inputs tags for $ROI_{q, 1, k}$:
$\{\text{tag}_1, \text{tag}_3, \text{tag}_4, \text{tag}_5\}$. 
Then tag vector $T_{p, 1, k}$ of $ROI_{p, 1, k}$ is $(1, 1, 1, 1, 0)$ and tag vector
$T_{q, 1, k}$ of $ROI_{q, 1, k}$ is $(1, 0, 1, 1, 1)$.

\subsubsection{Player Task Generator}

The \textbf{\hyperref[idx:ptg]{PTG}} combines task images from satellite and ResultDB.
A player task contains $2n$ different images in random order, that $n$ images are
the untagged new satellite images and $n$ images are tagged images of ResultDB, which means
\hyperref[idx:ptg]{PTG} contains two generating steps:

\begin{itemize}
\item [Step 1.] \hyperref[idx:ptg]{PTG} shall split a monitoring region into small pieces of images, 
and also assign a unique \textbf{image\_id} for each piece 
(The reason is discussed in section \ref{chapter:ethical} for the leakage of data).

\item [Step 2.] \hyperref[idx:ptg]{PTG} shall retrieve tagged images from ResultDB. Then combine
all images as a user task assign to a new upcoming player.
\end{itemize}

\subsubsection{Player Rating Model}

This subsection describes the \textbf{\hyperref[idx:prm]{PRM}} as well as its detection algorithm 
inside our Disaster Monitoring system.
The \hyperref[idx:prm]{PRM} is responsible for detect malicious players regarding their game task inputs.

PageRank was first proposed by Lary Page \cite{page1999pagerank} and 
applied to social analysis in \cite{bonacich2001eigenvector}. 
It is commonly used for expressing the stability of physical systems and the relative importance, 
so-called \textbf{centralities}, of the nodes of a network. 
We transfer the basic idea of centralities of a network
and use eigenvalue as the trust value for each player to distinguish malicious players and reliable players.

We establish the model in image dependent perspective. For a certain image $k$,
considering a directed \textbf{Player Rating Graph (PRG)\label{idx:prg}} 
between players who tagged the image $k$. Each player is a node of PRG, 
as illustrated in figure \ref{fig:graph2}. To define the graph weight, we introduce few input measurement


\begin{figure}[htp]
\centering
\includegraphics[width=0.3\columnwidth]{figures/graph}
\caption{Player Rating Model}
\label{fig:graph}
\end{figure}

% To define the edge weight, according to the database field design of a player, each player
% output ROIs for each task region of a player task, and each ROI contains a tags list, thus, 
% one can use three features: $\text{ROI}, \text{tags}, TV$.

\begin{definition}
\label{def:weightv}
The \textbf{Weight Vector} $V = (p(\text{tag}_1), p(\text{tag}_2), ..., p(\text{tag}_n))$ 
\textbf{of all tags} can be calculated by the following equation \ref{eq:ptag}:
\begin{equation}
\label{eq:ptag}
p(\text{tag}_i) = \frac{|\text{tag}_i|}{\sum_{j=1}^{n}{|\text{tag}_j|}}
\end{equation}
where
\begin{itemize}
\item $n$ is the number of current exist tags;
\item $|\text{tag}_i|$ is the occurrance of $\text{tag}_i$.
\end{itemize}
\end{definition}

\begin{definition}
\label{def:prmr}
The \textbf{Player ROI Matching Ratio (PRMR)} is an importance measurement that measures 
two different ROI intersection surface from player $p$ to player $q$ in a certain image $k$, 
which is donated by the following formula:
\begin{equation}
\text{PRMR}(p, q, i, j, k) = \frac{| ROI_{p,i,k} \cap ROI_{q,j,k} | }
       {|ROI_{p,i,k}|}
\end{equation}
\end{definition}

\begin{definition}
\label{def:ptc}

The \textbf{Player Input Tags Correlation (PITC)} is defined by weighted Pearson Correlation, 
which is donated by the following formula:
\begin{equation}
\text{PITC}(p, q, i, j, k) = \frac{Cov(T_{p,i,k}, T_{q,j,k}; v)}{Cov(T_{p,i,k}, T_{p,i,k}; v)}
\end{equation}
\end{definition}

Note that the PRMR and PITC both are not metrics due to $\text{PRMR}(p, q, i, j, k) \neq \text{PRMR}(q, p, i, j, k)$ as well as
$\text{PITC}(p, q, i, j, k) \neq \text{PITC}(q, p, i, j, k)$

\begin{definition}
For a certain image $k$, the edge weight of the PRG from player $p$ to player $q$ is donated 
by the following formula: \ref{eq:weight}:
\begin{equation}
\label{eq:weight}
w_{p,q,k} = 
\sum_{j=1}^{n}{
\sum_{i=1}^{m}{ \left(
  \text{PRMR}(p, q, i, j, k)
  \left(
    \text{PITC}(p, q, i, j, k) + 2
  \right)
\right)}}
\end{equation}

where 

\begin{itemize}
\item $ROI_{p, i, k}$ is the $i$-th selected ROI from player $p$;
\item $|ROI_{p, i, k}|$ is the surface of $ROI_{p, i, k}$;
\item $v$ is the \textbf{weight vector} of all tags
\item $T_{p, i, k}$ is the \textbf{tag vector} of $i$-th selected ROI from player $p$;
\item $Cov(x, y; v)$ is the weighted covariance of $x$ and $y$ via weight vector $v$.
\end{itemize}
\end{definition}

% The first part of the definition $\sum_{\text{ROI}\in\text{ROIs}}$ summarized all possible 
% ROI between player $i$ and player $j$. 

% We call the second part $\text{TV}_i \times \frac{\text{ROI}_i\cap\text{ROI}_j}{\text{ROI}_i}$ 
% of formula \ref{eq:weight} as \textbf{Matching Area Ratio (MAR)}. 
% It was inspired by a standard computer vision criteria,
% the so called Intersection over Union (IoU), also known as Jaccard Index \cite{real1996probabilistic},
% which is the standard performance measure that is commonly used for the object category segmentation problem.
% Nevertheless, MAR is not equal to the IoU of ROIs of player $i$  and 
% player $j$ since it only uses the ROI of player $i$ as denominator instead of 
% the union of ROIs of player $i$ and player $j$, which leads the difference between MAR and IoU. 
% There are two reasons to use MAR instead of IoU:
% Firstly, IoU as weight of graph causes the directed graph to an undirected graph due to 
% the IoU of player $i$ to $j$ is as same as the IoU of player $j$ to $i$; Furthermore, 
% player $i$ as the evaluator from $i$ to $j$ should be the performance base.

% The third part $\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$
% of formula \ref{eq:weight} is applied by Weighted Pearson Correlation Coefficient.

To calculate the eigenvalue of the adjacency matrix of PRG, one can use the normalized adjacency matrix 
through the following formula \ref{eq:normalize}:
\begin{equation}
\label{eq:normalize}
A_k = (a_{p,q,k}) = (\frac{w_{p,q,k}}{\sum_{q}{w_{p,q,k}}})
\end{equation}

where $k$ is the image indicator.

\begin{theorem}
The normalized ajacency matrix $A_k$ of PRG of a certain image $k$ is irreducible, real, 
non-negative, column-stochastic, and diagonal element being positive.
\end{theorem}

\begin{proof}
\textbf{Irreducibility}: For a certain image $k$, the PRG is strong connected because the
player who selected ROIs in image $k$ has a direct connection to any other player who also selected ROIs in image $k$ 
(the edge weight is well defined according to equation \label{eq:weight}).
Thus, since $A_k$ is an normalized strong connected PRG ajacency matrix, which proves $A_k$ is irreducible.

\textbf{Real elements}: Each part of the equation \label{eq:weight} are real number. Thus, of course,
the matrix $A_k$ elements are calculated by equation \label{eq:normalize} that are real elements.

\textbf{Non-negative elements}: We only need to prove $\text{TV}_i$, 
$\frac{\text{ROI}_i\cap\text{ROI}_j}{\text{ROI}_i}$ and 
$2-\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$ are non-negative 
respectively. $\text{TV}_i$ is the eigenvalues of normalized graph ajacency matrix, 
thus the codomain of $\text{TV}_i$ lies $(0, 1\rbrack$; For MAR, its range is obviously from 0 to 1,
which lies $\lbrack 0, 1 \rbrack$; For $2-\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$,
the Pearson Correlation lies on $[-1, 1]$, then this part lies on $[1, 3]$.
Three parts are non-negative.
  
\textbf{Positive diagonal elements}: The diagonal elements can be formalized by follows:

\[
w_{ii} = 
\sum_{\text{ROI}\in\text{ROIs}}{\left(
  \frac{\text{ROI}_i\cap\text{ROI}_i}{\text{ROI}_i}
  \left( \frac{Cov(T_i, T_i; v)}
      {Cov(T_i, T_i; v)\times Cov(T_i, T_i; v)} + 2 \right)\right)
} = \sum_{\text{ROI}\in\text{ROIs}}{\text{TV}_i} > 0
\]

\textbf{Column stochastic}: according to the definition of matrix $A$, the sum of the column
elements are:
\[
  \sum_{i}{\frac{w_{ij}}{\sum_{j}{w_{ij}}}} 
  = \frac{\sum_{i}{w_{ij}}}{\sum_{j}{w_{ij}}} = 1
\]
\end{proof}

We have proved the existence and uniqueness of eigenvalues of normalized PRG adjacency matrix; 
one can use the corresponding eigenvalues to represent the trust value of players. Thus, we have:

\begin{definition}
A \textbf{Trust Value} $TV_i$ of player $i$ represents by the $i$-th eigenvalue of normalized PRG ajacency matrix $A$.
\end{definition}

This definition can represent the rating score from $i$ to $j$. With the trust value of players,
we propose our classification algorithm:

\begin{algorithm}[H]
\label{algo:malicious}
\SetAlgoLined
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{anonymous IDs, TVs}
\Output{(anonymous\_id, isReliable)}
Calculate $TV_{new}$ as the trust value of player $new$ \;
\eIf{$TV_{new} \geq \frac{1}{|\text{players}|}\sum_{i\in \text{players}}{TV_{i}}$}{
  return $(\text{anonymous\_id}, \text{true})$
}{
  return $(\text{anonymous\_id}, \text{false})$
}
\caption{Player Classification Algorithm}
\end{algorithm}

In this algorithm, the criterion of classifying new players performs the action that 
the trust value of a new player should not be less than the mean value of overall trust value of players, 
which means the tagging performance of new player should not worth than result performance of former players.

Terefore in short, the input and output Data Model of PRM are as follows. For input:\\
$(\text{anonymous\_id}, \text{area\_id}, \text{time}, \text{ROIs}, \text{tags})$; 
For model output: 
$(\text{anonymous\_id}, \text{TV})$.

\subsubsection{Disaster Evaluation Model}
\label{chapter:dem}

For an area at time $t$, we address the \textbf{Disaster Evaluation Model (DEM)} 
via disaster level definition as follows:

\begin{definition}
\label{def:dl}
The \textbf{Disaster Level (DL)} of a monitor region is calculated by each area components:
\[
  DL = \sum_{\text{area}\in\text{region}}{DL_{\text{area}}}
\]
where $DL_{\text{area}}$ is calculated by its corresponding tag vector:
\[
  DL_{\text{area}} = \sum_{i=1}^{n}{v_i \times |\text{tag}_i|}
\]
with $n$ is the number of current exist tags, and $|\text{tag}_i|$ is the occurrance of $\text{tag}_i$
in the corresponding area.
\end{definition}

System like ESP \cite{von2004labeling}, ARTigo \cite{wieser2013artigo} has proved that 
human inputs are valuable and useful.

Note that sometimes player carries new tags for our system, we also address a solution 
for this issue via the following steps:

\begin{itemize}
\item When a player carries predefined tags: Trivial;
\item When a player carries new tags: Directly drop, it is an unreliable result;
\item When a player carries predefined tags and also new tags: calculate the trust value without new tags;
  merge and update all weight vector $v$ via formula \ref{eq:weight} if the player is reliable, 
  otherwise drop and mark the result is unreliable.
\end{itemize}

With this definition \ref{def:dl}, we can calculate the disaster level for a monitoring region.
To sum up, the input and the output Data Model of DEM addresse as follows. For input:
$(\text{time})$, $(\text{area\_id})$ or $(\text{area\_id}, \text{time})$; For output:
$(\text{area\_id}, \text{time}, \text{disaster\_level})$.

\subsection{Model Initialization}
\label{chapter:modelinit}

A cold start of such a system is a common problem in human computation system that 
is avoided by hiring people to play or learn as long as 
the number of users or the quantity of data is insufficient.
In our system, we have two different cold start problem.

The first cold start problem appears in the PTG. To initialize the whole system, we need to
address an initial trusted group for PTG; they shall tagging enough initial trusted result
for PTG and then assign to new upcoming players. When a new player is reliable,
then the result of this player will become reliable. Meanwhile, the trusted group and 
available dataset grow larger with this step repeatedly, as shown in figure \ref{fig:cold}.

\begin{figure}[htp]
\centering
\includegraphics[width=0.5\columnwidth]{figures/coldstart}
\caption{Cold Start of PTG}
\label{fig:cold}
\end{figure}

The second cold start problem appears in PRM. According to the definition \ref{eq:weight} of PRG, the weight
of PRG was defined by the trust value of all players. Nevertheless, the initial trusted group has
no trust value. Thus we need an initial value for $TV$. Note that TV\_i is in between of 0 and 1, thus:

\[
TV_{i}^{\text{init}} = \frac{1}{|\text{players}^{\text{init}}|}
\]

with $|\text{players}^{init}|$ is the number of initial trusted group. 

\subsection{Discussion on image independent model}
