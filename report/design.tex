\section{Design}

In this chapter, we describe the overall design of our disaster monitoring backend system in details.
Firstly, we propose our system architecture of this disaster monitoring;
Then we specify and justify our most critical system components such as databases design, 
\textbf{Player Task Generator}, \textbf{Player Rating Model} as well as \textbf{Disaster Evaluation Model}.

With these components, model and databases, the disaster monitoring system can handle
common problems in HC system, such as cold start, malicious player detection, etc. 
It is also expandable, portable and can be easily applied to any other same image selection 
and tagging based HC system in different areas.

\subsection{System Architectures}

Figure \ref{fig:arch} illustrate the overall disaster system design.
The system databases are composed of two different type of databases. 
The first database \textbf{PlayerDB} combines \textbf{TrustedDB} and \textbf{UntrustedDB} 
where persistent the player property and raw tagging inputs whether the overall result is reliable or not.
The second database is called \textbf{ResultDB} where persistent the reliable player inputs.

\begin{figure}[htp]
\centering
\includegraphics[width=0.9\textwidth]{figures/system2}
\caption{System Design Overview}
\label{fig:arch}
\end{figure}

For this architecture design, one can simplify the overall data flow into tree main steps 
that describes as follows:

\begin{itemize}

\item [Step 1.]  Player task generating: 
We propose the \textbf{Player Task Generator (PTG)}
that combines trusted results from \textbf{TrustedDB}, 
and separate new images from satellite, then assign this binding to the future players.

\item [Step 2.] Malicious player detection: 
A reliable player shall pass the malicious detection algorithm (describe in \ref{TODO:add})
inside the \textbf{Player Rating Model (PRM)}. 
Once the player is not a malicious player, then system will mark all the results from this player
as a reliable result and then send it into next step.

\item [Step 3.] Evaluating disaster level:  the system reuse the reliable player inputs 
into \textbf{Disaster Evaluation Model (DEM)} and calculate the disaster level of the monitoring region
 as well as persistent it in the second database \textbf{ResultDB}.

\end{itemize}

After these three main steps, stakeholders are able to retrieve monitoring results from
the database \textbf{ResultDB}. 

\subsection{System Components}

\subsubsection{Database Fields}

We describe the system database PlayerDB 
fields as well as the fields of database ResultDB first in listing \ref{lst:playerdb}
and \ref{lst:resultdb}.

In this disaster monitoring system, our participants \textbf{do not need to register accounts},
and the system shall \textbf{assign an anonymous\_id for each player}. 
This function significantly accelerate player to participate in this game. 
Thus, the \textbf{PlayerDB} stores the anonymous\_id to detect the same players if they are involved next time. 
The player will accomplish different game tasks; each task result shall store in the tasks filed.

TODO: fix database design

In the \textbf{ResultDB}, an area ID is unique and assigned by our system. 
Our player shall evaluate each area, and the evaluation history stories in the history field.


\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[
    caption={Player Database Fields Design},
    label={lst:playerdb}
]
[
 {
  "anonymous_id": number,
  "tasks": [
   {
    "image": string,
    "at": time,
    "reliable": boolean,
    "ROI": [
     {
      "latitude": number,
      "longitude": number,
      "tags": [tag1, tag2, ...]
     }, ...
    ]
   }
  ]
 }, ...
]
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[
  caption={Results Database Fields Design},
  label={lst:resultdb}
]
[
 {
  "region_id": number,
  "history": [
   {
    "image": string,
    "at": time,   
    "ROI": [
     {
      "latitude": number,
      "longitude": number,
      "tags": [tag1, tag2, ...]
     }, ...
   ]
  }, 
  ...
 ]
}, ...
]
\end{lstlisting}
\end{minipage}

To explain other fields and establish our models, we describe few basic definition for the system models.

\begin{definition}
\label{def:roi}
The \textbf{Region of Interests (ROI)} is an indicator that represents the one of the selected two dimensional regions from player. 
The $i$-th ROI from player $p$ in image $k$ at image creation time $t$ is denoted by $ROI_{p,i,k,t}$.
\end{definition}

Considering image $k$ \textbf{implies} its creation time $t$ (an image alwasy has its creation time), for convenience, 
we usually \textbf{simplify $ROI_{p,i,k,t}$ to $ROI_{p,i,k}$}.
For instance, figure \ref{fig:roi} shows few examples of ROI on different images.

\begin{figure}[htp]
\centering
\includegraphics[width=0.9\textwidth]{figures/roi}
\caption{Examples of Region of Interests (ROI)}
\label{fig:roi}
\end{figure}

% 通过这个定义，我们可以看到：两个 listing 中的 ROI 被设计为一个数组，因为无论是一个 image task object 还是一个 region 的 image area object, 都
With this definition, 

\begin{definition}
\label{def:tagv}
The \textbf{Tag Vector} $T_{p, i, k}$ of $ROI_{p, i, k}$ (the $i$-th ROI on image $k$ of player $p$) is a vector that 
is donated by the following formula:
:
\[
  T_{p, i, k} = (|\text{tag}_1|, |\text{tag}_2|, ..., |\text{tag}_n|)
\]
where 
\begin{itemize}
\item $tag_i$ is the $i$-th tag
\item $n$ is the number of current exist tags;
\item $|\text{tag}_n|$ is the occurrance of $\text{tag}_n$.
\end{itemize}
\end{definition}

\begin{definition}
\label{def:weightv}
The \textbf{Weight Vector} $V = (p(\text{tag}_1), p(\text{tag}_2), ..., p(\text{tag}_n))$ 
\textbf{of all tags} can be calculated by the following equation \ref{eq:ptag}:
\begin{equation}
\label{eq:ptag}
p(\text{tag}_i) = \frac{|\text{tag}_i|}{\sum_{j=1}^{n}{|\text{tag}_j|}}
\end{equation}
where
\begin{itemize}
\item $n$ is the number of current exist tags;
\item $|\text{tag}_i|$ is the occurrance of $\text{tag}_i$.
\end{itemize}
\end{definition}

% For instance, there are 5 different tags $\text{tag}_1, \text{tag}_2, \text{tag}_3, \text{tag}_4, \text{tag}_5$ 
% exist in the current system,
% player $i$ generates tags list $\{\text{tag}_1, \text{tag}_2, \text{tag}_3\}$, player $j$ generates tag list
% $\{\text{tag}_3, \text{tag}_4, \text{tag}_5\}$. Then $T_i$ of player $i$ is $(1, 1, 1, 0, 0)$ and 
% $T_j$ of player $j$ is $(0, 0, 0, 1, 1)$.

\subsubsection{Player Task Generator}

% The \textbf{Player Task Generator (PTG)} combines images from satellite and ResultDB. 
% In the first step, as we discussed before, to solve the imformation leakage problem,
% PTG shall split a monitoring region into $m\times n$ small pieces of images, and also assign a 
% unique \textbf{areaID} for each pieces, i.e. $(\text{areaID}, \text{time})$ 
% specifice a unique image for user tasks. 

% The second generating step is to retrieve tagged images from \textbf{ResultDB}. Then combine
% all images as a user task assign to a new upcoming player. Each user task contains 
% half of untagged pictures and half of tagged images.

% In short, The Data Model (only ouput here) for PTG is:
% $\{(\text{areaID}_1, \text{time}_1), ..., (\text{areaID}_n, \text{time}_n)\}$
% with $\text{areaID}_1$ to $\text{areaID}_{\floor{n}}$ are from satellite and 
% $\text{areaID}_{\floor{n}+1}$ to $\text{areaID}_{n}$ are from \textbf{ResultDB}.

\subsubsection{Player Rating Model}

% This subsection describes the Player Rating Model inside our Disaster Monitoring system.

% PageRank was first proposed by Lary Page \cite{page1999pagerank} and 
% applied to social analysis in \cite{bonacich2001eigenvector}. 
% It is commonly used for expressing the stability of physical systems and the relative importance, 
% so-called \textbf{centralities}, of the nodes of a network. 

% We transfer the basic idea of centralities of a network
% and use eigenvalue as \textbf{Trust Value (TV)} for each player to distinguish malicious players.

Considering a partial fully connected directed graph between players. 
Each player is a node of the Player Rating Graph (PRG) as illustrated in figure \ref{fig:graph}.

\begin{figure}[htp]
\centering
\includegraphics[width=0.3\columnwidth]{figures/graph}
\caption{Player Rating Model}
\label{fig:graph}
\end{figure}

% To define the edge weight, according to the database field design of a player, each player
% output ROIs for each task region of a player task, and each ROI contains a tags list, thus, 
% one can use three features: $\text{ROI}, \text{tags}, TV$.

\begin{definition}
For a certain image $k$, the edge weight of the PRG from player $p$ to player $q$ is donated 
by the following formula: \ref{eq:weight}:
\begin{equation}
\label{eq:weight}
w_{p,q,k} = 
\sum_{j=1}^{n}{
\sum_{i=1}^{m}{ \left(
  \frac{ | ROI_{p,i,k} \cap ROI_{q,j,k} | }
       {|ROI_{p,i,k}|}
  \left(
    \frac{Cov(T_{p,i,k}, T_{q,j,k}; v)}{Cov(T_{p,i,k}, T_{p,i,k}; v)Cov(T_{q,j,k}, T_{q,j,k}; v)} + 2
  \right)
\right)}}
\end{equation}

where 

\begin{itemize}
\item $ROI_{p, i, k}$ is the $i$-th selected ROI from player $p$;
\item $|ROI_{p, i, k}|$ is the surface of $ROI_{p, i, k}$;
\item $v$ is the \textbf{weight vector} of all tags
\item $T_{p, i, k}$ is the \textbf{tag vector} of $i$-th selected ROI from player $p$;
\item $Cov(x, y; v)$ is the weighted covariance of $x$ and $y$ via weight vector $v$.
\end{itemize}
\end{definition}

% The first part of the definition $\sum_{\text{ROI}\in\text{ROIs}}$ summarized all possible 
% ROI between player $i$ and player $j$. 

% We call the second part $\text{TV}_i \times \frac{\text{ROI}_i\cap\text{ROI}_j}{\text{ROI}_i}$ 
% of formula \ref{eq:weight} as \textbf{Matching Area Ratio (MAR)}. 
% It was inspired by a standard computer vision criteria,
% the so called Intersection over Union (IoU), also known as Jaccard Index \cite{real1996probabilistic},
% which is the standard performance measure that is commonly used for the object category segmentation problem.
% Nevertheless, MAR is not equal to the IoU of ROIs of player $i$  and 
% player $j$ since it only uses the ROI of player $i$ as denominator instead of 
% the union of ROIs of player $i$ and player $j$, which leads the difference between MAR and IoU. 
% There are two reasons to use MAR instead of IoU:
% Firstly, IoU as weight of graph causes the directed graph to an undirected graph due to 
% the IoU of player $i$ to $j$ is as same as the IoU of player $j$ to $i$; Furthermore, 
% player $i$ as the evaluator from $i$ to $j$ should be the performance base.

% The third part $\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$
% of formula \ref{eq:weight} is applied by Weighted Pearson Correlation Coefficient.

To calculate the eigenvalue of the adjacency matrix of PRG, one can use the normalized adjacency matrix 
through the following formula \ref{eq:normalize}:
\begin{equation}
\label{eq:normalize}
A_k = (a_{p,q,k}) = (\frac{w_{p,q,k}}{\sum_{q}{w_{p,q,k}}})
\end{equation}

where $k$ is the image indicator.

\begin{theorem}
The normalized ajacency matrix $A_k$ of PRG of a certain image $k$ is irreducible, real, 
non-negative, column-stochastic, and diagonal element being positive.
\end{theorem}

\begin{proof}
\textbf{Irreducibility}: For a certain image $k$, the PRG is strong connected because the
player who selected ROIs in image $k$ has a direct connection to any other player who also selected ROIs in image $k$ 
(the edge weight is well defined according to equation \label{eq:weight}).
Thus, since $A_k$ is an normalized strong connected PRG ajacency matrix, which proves $A_k$ is irreducible.

\textbf{Real elements}: Each part of the equation \label{eq:weight} are real number. Thus, of course,
the matrix $A_k$ elements are calculated by equation \label{eq:normalize} that are real elements.

\textbf{Non-negative elements}: We only need to prove $\text{TV}_i$, 
$\frac{\text{ROI}_i\cap\text{ROI}_j}{\text{ROI}_i}$ and 
$2-\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$ are non-negative 
respectively. $\text{TV}_i$ is the eigenvalues of normalized graph ajacency matrix, 
thus the codomain of $\text{TV}_i$ lies $(0, 1\rbrack$; For MAR, its range is obviously from 0 to 1,
which lies $\lbrack 0, 1 \rbrack$; For $2-\frac{Cov(T_i, T_j; v)}{Cov(T_i, T_i; v)\times Cov(T_j, T_j; v)}$,
the Pearson Correlation lies on $[-1, 1]$, then this part lies on $[1, 3]$.
Three parts are non-negative.
  
\textbf{Positive diagonal elements}: The diagonal elements can be formalized by follows:

\[
w_{ii} = 
\sum_{\text{ROI}\in\text{ROIs}}{\left(
  \frac{\text{ROI}_i\cap\text{ROI}_i}{\text{ROI}_i}
  \left( \frac{Cov(T_i, T_i; v)}
      {Cov(T_i, T_i; v)\times Cov(T_i, T_i; v)} + 2 \right)\right)
} = \sum_{\text{ROI}\in\text{ROIs}}{\text{TV}_i} > 0
\]

\textbf{Column stochastic}: according to the definition of matrix $A$, the sum of the column
elements are:
\[
  \sum_{i}{\frac{w_{ij}}{\sum_{j}{w_{ij}}}} 
  = \frac{\sum_{i}{w_{ij}}}{\sum_{j}{w_{ij}}} = 1
\]
\end{proof}

We have proved the existence and uniqueness of eigenvalues of normalized PRG adjacency matrix; 
one can use the corresponding eigenvalues to represent the trust value of players. Thus, we have:

\begin{definition}
A \textbf{Trust Value} $TV_i$ of player $i$ represents by the $i$-th eigenvalue of normalized PRG ajacency matrix $A$.
\end{definition}

This definition can represent the rating score from $i$ to $j$. With the trust value of players,
we propose our classification algorithm:

\begin{algorithm}[H]
\SetAlgoLined
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{anonymous IDs, TVs}
\Output{(anonymous\_id, isReliable)}
Calculate $TV_{new}$ as the trust value of player $new$ \;
\eIf{$TV_{new} \geq \frac{1}{|\text{players}|}\sum_{i\in \text{players}}{TV_{i}}$}{
  return $(\text{anonymous\_id}, \text{true})$
}{
  return $(\text{anonymous\_id}, \text{false})$
}
\caption{Player Classification Algorithm}
\end{algorithm}

In this algorithm, the criterion of classifying new players performs the action that 
the trust value of a new player should not be less than the mean value of overall trust value of players, 
which means the tagging performance of new player should not worth than result performance of former players.

Terefore in short, the input and output Data Model of PRM are as follows. For input:\\
$(\text{anonymous\_id}, \text{area\_id}, \text{time}, \text{ROIs}, \text{tags})$; 
For model output: 
$(\text{anonymous\_id}, \text{TV})$.

\subsubsection{Disaster Evaluation Model}
\label{chapter:dem}

For an area at time $t$, we address the \textbf{Disaster Evaluation Model (DEM)} 
via disaster level definition as follows:

\begin{definition}
\label{def:dl}
The \textbf{Disaster Level (DL)} of a monitor region is calculated by each area components:
\[
  DL = \sum_{\text{area}\in\text{region}}{DL_{\text{area}}}
\]
where $DL_{\text{area}}$ is calculated by its corresponding tag vector:
\[
  DL_{\text{area}} = \sum_{i=1}^{n}{v_i \times |\text{tag}_i|}
\]
with $n$ is the number of current exist tags, and $|\text{tag}_i|$ is the occurrance of $\text{tag}_i$
in the corresponding area.
\end{definition}

System like ESP \cite{von2004labeling}, ARTigo \cite{wieser2013artigo} has proved that 
human inputs are valuable and useful.

Note that sometimes player carries new tags for our system, we also address a solution 
for this issue via the following steps:

\begin{itemize}
\item When a player carries predefined tags: Trivial;
\item When a player carries new tags: Directly drop, it is an unreliable result;
\item When a player carries predefined tags and also new tags: calculate the trust value without new tags;
  merge and update all weight vector $v$ via formula \ref{eq:weight} if the player is reliable, 
  otherwise drop and mark the result is unreliable.
\end{itemize}

With this definition \ref{def:dl}, we can calculate the disaster level for a monitoring region.
To sum up, the input and the output Data Model of DEM addresse as follows. For input:
$(\text{time})$, $(\text{area\_id})$ or $(\text{area\_id}, \text{time})$; For output:
$(\text{area\_id}, \text{time}, \text{disaster\_level})$.

\subsection{Model Initialization and System Cold Start}

A cold start of such a system is a common problem in human computation system that 
is avoided by hiring people to play or learn as long as 
the number of users or the quantity of data is insufficient.
In our system, we have two different cold start problem.

The first cold start problem appears in the PTG. To initialize the whole system, we need to
address an initial trusted group for PTG; they shall tagging enough initial trusted result
for PTG and then assign to new upcoming players. When a new player is reliable,
then the result of this player will become reliable. Meanwhile, the trusted group and 
available dataset grow larger with this step repeatedly, as shown in figure \ref{fig:cold}.

\begin{figure}[htp]
\centering
\includegraphics[width=0.5\columnwidth]{figures/coldstart}
\caption{Cold Start of PTG}
\label{fig:cold}
\end{figure}

The second cold start problem appears in PRM. According to the definition \ref{eq:weight} of PRG, the weight
of PRG was defined by the trust value of all players. Nevertheless, the initial trusted group has
no trust value. Thus we need an initial value for $TV$. Note that TV\_i is in between of 0 and 1, thus:

\[
TV_{i}^{\text{init}} = \frac{1}{|\text{players}^{\text{init}}|}
\]

with $|\text{players}^{init}|$ is the number of initial trusted group. 

\subsection{Discussion on image independent model}
